1.Претходно внесен број
-ни треба flag да знаеме каде се наоѓаме
int prethoden = -1;
 bool prv = true; -означува дека се наоѓаме во прв број
    while (cin >> br) {
        if (prv == true) {
            prv = false;

            cout << br << ":" << zbir_cifri(br) << endl;
        } else {
cout<<br<<":"<<max_cifra(prethoden)+zbir_cifri(br)<<endl;
        }
        prethoden=br;//prethoden НЕ СМЕЕ НАДВОР ОД WHILE, бидејќи така ќе се ажурира само еднаш, откако ќе заврши внесувањето на сите броеви.,сега претходен е внесениот број бидејќи
//влегува во првиот ,ако влезе во if-от во таа итерација else делот не се извршува
   //  МОРА ВО РАМКИ НА WHILE
    }



2.
 int statistika[5]={0};
statistika[maxPos]++;//брои колку пати се појавува секоја позиција.На таа позиција која е максимална брои колку пати пример statistika[1] на втора позиција ++ значи имаме 0+1 =1 +1 итн 
//0 бидејќи така е иницијализирана низата


3.Земање наизменично последна,претпоследна цифра
 int prev=num%10;//последната ја зачувуваме
num/=10;//ја отстрануваме
while (num>0) {
int curr=num%10;//претходната е оваа бидејќи уште пред да влеземе во while-от сме ја отстраниле последната 
 prev=curr;//сега curre е prev 
     num/=10;//ја отстрануваме цифрата  и сега повторно почетокот 
ПРИМЕР:num = 394
num = 394
%10
Последна цифра: prev = 4

num станува 39

Итерација 1:

curr = 9 (следна цифра од десно)
prev = 9 поради  prev=curr;

num = 3// num = 39 / 10 = 3




4.НИЗА ПАЛИНДРОМ
bool isPalindrome(char *str) {
    for (int i=0;i<strlen(str)/2;i++) {
        if (str[i]!=str[strlen(str)-1-i]) {//овде е со негација бидејќи за да биде палиндром не смее ниту една да е различна ,ако ставевме обратна логика т.е ако се исти да врати true тоа ќе врати true
//одма без да ја провери целата низа,затоа return true е надвор од for loop-от кога ќе се заврши со проверката ако не е најдена различна тогаш е палиндром
            return false;
        }
    }
    return true;
}





5.ПРЕТВАРАЊЕ ВО МАЛИ БУКВИ 
     // Претвори во мали букви
//ПРЕТХОДНО СИ ИМА ПОСЕБЕН FOR ЗА ЧИТАЊЕ КОЈШТО Е НАДВОРЕШЕН НА РЕЧЕНИЦИ,НО ОВА НИ Е ЗА ДА ЈА ПРЕТВОРИМЕ СЕКОЈА ВО МАЛА БУКВА ,СЕКОЈ 1 КАРАКТЕР ВО РАМКИТЕ НА ТАА РЕДИЦА
        int len = strlen(niz);
        for (int k = 0; k < len; k++) {
            niz[k] = tolower(niz[k]);
        }


6.ВО МАТРИЦА ПРОВЕРКА ПО РЕДИЦИ АКО САКАМЕ 

прво го селектираме for циклусот за редици пример 

 // Проверка по редици
    for (int i = 0; i < m; i++) {
        int rediciCounter = 0;
        bool found = false;
        for (int j = 0; j < n; j++) {
            if (matrica[i][j]==1) rediciCounter++;
            else rediciCounter = 0;

            if (rediciCounter >= 3) found = true;
        }
        if (found) vkupnoRedici++;
    }


ВО МАТРИЦА ПРОВЕРКА ПО КОЛОНИ АКО САКАМЕ 

прво го селектираме for циклусот за колони пример 

// Проверка по колони
    for (int j = 0; j < n; j++) {
        int koloniCounter = 0;
        bool found = false;
        for (int i = 0; i < m; i++) {
            if (matrica[i][j]==1) koloniCounter++;
            else koloniCounter = 0;

            if (koloniCounter >= 3) found = true;
        }
        if (found) vkupnoKoloni++;
    }


7.ПАРНОСТ НА ЕЛЕМЕНТ ДАЛИ Е ИСТ СО ПАРНОСТ НА ЗБИР НА ИДЕКСИТЕ
  if (matrica[i][j]%2==(i+j)%2) 



8.Последнователни појавувања пример на соседни
 *самогласки во речениците.

for (int i=0;i<strlen(str)-1;i++) {//-1 мора да има бидејќи оди до следниот на низата и затоа последната проверка може да се прави кога ќе биде претпоследниот елемент од низата значи за последователни 2
 if ( isVowel(str[i])&& isVowel(str[i+1])) {//isVowel е bool ф-ја која е кориснички дефинирана претходно и овде само ја повикуваме со нејзиниот аргумент
counter++;
}}



9.ПРИМЕР : Да се најде најдолгиот ред во кој има барем 2 цифри
-Мора прво да се исполни условот за барем 2 цифри за да потоа се пребарува најдолгиот ред
-Ако бараме најдолг ред,значи тоа е во рамки на while за секој ред т.е се додека влегува во while,затоа 
  while (true) {
        int counter=0;.....

if (counter>=2) {
        if (strlen(str)>maxRed) {
            maxRed=strlen(str);
            strcpy(najdolgStr,str);
       }
    }



10.PATTERN

1234...N...4321
………..
123454321
1234321
12321
121
1

int main() {
    int n;
    cin>>n;
    for (int i=0;i<n;i++) {//во рамки на редот ,пример првиот
for(int j=1;j<=n-i;j++) { //зависи од редот ова како се намалува n-i => 12345
    cout<<j;
}
        for (int j=n-i-1;j>0;j--) {//ова продолжува во рамки на истиот ред но одпозади за n-1 за да не ни се дуплира n
            cout<<j;
        }

        cout<<endl;
    }
}



PATTERN

1
121
11311
1114111
……
11..1N11...11


 cin>>n;
    for (int i=1;i<=n;i++) {//за секој од редовите 
        for (int j=0;j<i-1;j++) {
cout<<"1";

}
cout<<i;

 for(int j=0;j<i-1;j++){
     cout<<"1";
 }
        cout<<endl;
    }





11.МАТРИЦА СО БУКВИ

редовите со парен индекс (0, 2, 4, ...) се пополнуваат од лево кон десно
редовите со непарен индекс (1, 3, 5, ...) се пополнуваат од десно кон лево
Буквите се користат циклично и по редослед, т.е. после буквата I, се продолжува пак од А.

 int n;
    char bukva='A';
    cin>>n;
    char matrica[100][100];
    for (int i=0;i<n;i++) {
        if (i%2==0){
        for (int j=0;j<n;j++) {
           if (bukva=='I') {
               bukva='A';
           }
                matrica[i][j]=bukva++;
            }
        }
        else {
            for (int j=n-1;j>=0;j--) {
                if (bukva=='I') {
                    bukva='A';
                }
                matrica[i][j]=bukva++;

            }

        }
    }

12.Секоја буква се заменува со буквата што е 3 места понапред во азбуката .За буквите на крајот од азбуката, броењето продолжува циклично од почетокот на азбуката.

char shiftChar(char c) {
    c=tolower(c);
    if (isalpha(c)) {
        c=((c-'a'+3)%26)+'a';
    }
    return c;
}


c - 'a' → ја наоѓа позицијата на буквата во азбуката (пример 'a' = 0, 'b' = 1, … 'z' = 25).

+ 3 → поместува 3 места напред.

% 26 → за да остане во граници на азбуката (ако стигнеме после 'z', да се врати на почеток).

+ 'a' → ја враќа назад во буква.



13.КОЛКУ ПАТИ СЕ ПОЈАВУВА НАЈМАЛЦЕ ЗНАЧАЈНАТА ЦИФРА ВО 1 БРОЈ -ПОСЛЕДНА ЦИФРА Е НАЈМАЛЦЕ ЗНАЧАЈНА %10

int najmalceZnacajna(int n) {
    int temp=n;
    int last=temp%10;
    int counter=0;
while (n>0) {
    if (last==n%10)
    counter++;
    n=n/10;
}
return counter;


}



14./*Напиши програма која ќе чита непознат број од три цели броеви, и за секоја тројка (a, b, c) ќе го испечати бројот
 *(a или b) што ја содржи цифрата c повеќе пати на парни позиции (позициите се бројат од десно кон лево, а првата позиција е 1).
 */
#include<iostream>
using namespace std;
int cifraCTimes(int n,int c) {
    int counter=0;
    int pos=1;
    while (n>0) {
        int cifra=n%10;
        if (cifra==c&&pos%2==0) {
            counter++;

        }
        pos++;
        n=n/10;
    }
    return counter;
}
int main() {
    int a,b,c;
    while (cin>>a>>b>>c) {
int countA=cifraCTimes(a,c);
       int countB= cifraCTimes(b,c);
        if (countA>=countB) {
            cout<<a<<endl;

        }
        else {
            cout<<b<<endl;
        }
    }
}


15./*
 *Прочитај ги димензиите на матрицата ,па самата матрица
 *Прочитајте ги координатите на еден елемент од матрицата.
 *Ако елементот на позицијата за читање е 0, тогаш треба да стане 1 и:
сите нули над тој елемент до првиот елемент со вредност 1 или до почетокот на колоната,
сите нули под тој елемент до првиот елемент со вредност 1 или до крајот на колоната,
сите нули лево од тој елемент до првиот елемент со вредност 1 или до почетокот на редот и
сите нули десно од тој елемент до првиот елемент со вредност 1 или до крајот на редот.
Ако елементот на дадената позиција е 1, тогаш матрицата останува непроменета.
Испечатете ја променетата матрица.
 */
#include <iostream>
using namespace std;

int main() {
 int m, n;
 cin >> m >> n;
 int A[100][100];

 // Вчитување на матрицата
 for (int i = 0; i < m; i++)
  for (int j = 0; j < n; j++)
   cin >> A[i][j];

 int x, y;
 cin >> x >> y; // координати на елементот

 // Проверка дали е 0
 if (A[x][y] == 0) {
  A[x][y] = 1;

  // Горе
  for (int i = x-1; i >= 0; i--) {
   if (A[i][y] == 1) break;
   A[i][y] = 1;
  }

  // Долу
  for (int i = x+1; i < m; i++) {
   if (A[i][y] == 1) break;
   A[i][y] = 1;
  }

  // Лево
  for (int j = y-1; j >= 0; j--) {
   if (A[x][j] == 1) break;
   A[x][j] = 1;
  }

  // Десно
  for (int j = y+1; j < n; j++) {
   if (A[x][j] == 1) break;
   A[x][j] = 1;
  }
 }

 // Печатење на резултатот
 for (int i = 0; i < m; i++) {
  for (int j = 0; j < n; j++) {
   cout << A[i][j] << " ";
  }
  cout << endl;
 }

 return 0;
}


16./*
 *Напишете програма каде што матрицата А прочитана од SI (максималната вредност на димензиите на матрицата е 100)
 се трансформира во нова матрица B. Секој елемент од новата матрица B е збир од позитивни соседи на соодветниот елемент
 од матрицата A. Испечатете ја новата матрица B на стандардниот излез.
 */
#include<iostream>
using namespace std;
int main() {
    int n,m;
    int matrica[100][100];
    int b[100][100];
    cin>>n>>m;
    for (int i=0;i<n;i++) {
        for (int j=0;j<m;j++) {
            cin>>matrica[i][j];
        }
    }
for (int i=0;i<n;i++) {
    for (int j=0;j<m;j++) {
        int suma=0;
        //gore
        if (i-1>=0 && matrica[i-1][j]>0) {
            suma+=matrica[i-1][j];
        }
        //dole
        if (i+1<n &&matrica[i+1][j]>0) {
            suma+=matrica[i+1][j];
        }
        //levo
        if (j-1>=0 && matrica[i][j-1]>0) {
            suma+=matrica[i][j-1];
        }
        //desno
        if (j+1<m &&matrica[i][j+1]>0) {
            suma+=matrica[i][j+1];
        }
        b[i][j]=suma;
    }
}
    for (int i=0;i<n;i++) {
        for (int j=0;j<m;j++) {
            cout<<b[i][j];
        }
        cout<<endl;
    }



}


17.
/*
 *Напишете програма која ќе чита низа (не подолга од 100 знаци) што содржи букви и цифри.
 *Програмата треба да ги испечати на стандардниот излез буквите што се наоѓаат помеѓу првата и втората цифра,
 *од лево кон десно, вклучувајќи ги и самите цифри што ја граничат. Ако низата има само една цифра, програмата треба да
ги испечати сите букви до крајот на низата. Ако низата нема цифри, програмата треба да ја испечати пораката „Нема цифри“
 */
#include<iostream>
#include<cstring>
using namespace std;
int main() {
 char str[100];
 int firstDigit=-1;
 int secondDigit=-1;
 cin.getline(str,100);
 //bukvi megju prva i vtora cifra
 for (int i=0;i<strlen(str);i++) {
  if (isdigit(str[i])) {
   if (firstDigit==-1){
    firstDigit=i;
   }
   else{
    secondDigit=i;
    break;//najdena e vtorata
   }
  }
 }

  if (secondDigit==-1) {//ako ima samo 1 cifra
   for (int i=firstDigit;i<strlen(str);i++) {
    cout<<str[i];
   }
  }
  else if (firstDigit==-1&&secondDigit==-1) {
   cout<<"Nema cifri";
  }
  else {
   for (int i=firstDigit;i<=secondDigit;i++) {
    cout<<str[i];
   }

  }
 }




18./*
*Напишете програма што ќе ја трансформира низата на следниов начин: почнувајќи од почетокот на низата,
за секој елемент што е еднаков на следниот елемент во низата, удвојте ја вредноста на првиот и пребришете ја
втората со 0. После тоа, преуредете ја низата така што сите нули ќе бидат поместени на крајот од низата,
задржувајќи го редоследот на другите елементи. Испечатете ги сите елементи од низата на SO во еден ред,
одделени со празно место.
 */
#include<iostream>
using namespace std;
void transform(int a[],int n) {
    for (int i=0;i<n-1;i++) {
        if (a[i]==a[i+1]) {
            a[i]=a[i]*2;
            a[i+1]=0;
        }
    }
}
void pomestiNuliNaKraj(int a[],int n) {
    int pos=0;
    for (int i=0;i<n;i++) {
        if (a[i]!=0) {
            a[pos++]=a[i];
        }

    }
    while (pos<n) {
        a[pos++]=0;
    }

}
int main() {
    int n;
    int niza[100];
    cin>>n;
    for (int i=0;i<n;i++) {
        cin>>niza[i];
    }
    transform(niza,n);
    pomestiNuliNaKraj(niza,n);
    for (int i=0;i<n;i++) {
        cout<<niza[i]<<" "<<endl;
    }

}



19./*
 *Трансформирајте ја матрицата на начин што сите елементи НАД главната дијагонала ќе бидат поставени на
 *вредноста на максималниот елемент што се наоѓа над главната дијагонала, додека сите елементи ПОД главната
 *дијагонала ќе бидат поставени на вредноста на минималниот елемент што се наоѓа под главната дијагонала.
 *Испечатете ја трансформираната матрица.
 */
#include<iostream>
using namespace std;
int main() {
    int n;
    int matrica[100][100];
    cin>>n;
    for (int i=0;i<n;i++) {
        for (int j=0;j<n;j++) {
            cin>>matrica[i][j];
        }
    }
    //nad glavna dijagonala
    int sum=0;
    int max=matrica[0][1];
    int min=matrica[1][0];
    for (int i=0;i<n;i++) {
        for (int j=0;j<n;j++) {
            if (j>i) {
                if (matrica[i][j]>max) {

                    max=matrica[i][j];
                }
            }
        }
    }
//pod glavna
    for (int i=0;i<n;i++) {
        for (int j=0;j<n;j++) {
            if (j<i) {
                if (matrica[i][j]<min) {

                    min=matrica[i][j];
                }
            }
        }
    }
    for (int i=0;i<n;i++) {
        for (int j=0;j<n;j++) {
            if (j>i) {
                matrica[i][j]=max;
            }
        }
    }
    for (int i=0;i<n;i++) {
        for (int j=0;j<n;j++) {
            if (j<i) {
                matrica[i][j]=min;
            }
        }
    }
    for (int i=0;i<n;i++) {

        for (int j=0;j<n;j++) {
            cout<<matrica[i][j]<<" ";
        }
        cout<<endl;
    }

}



20.ФАКТОРИЕЛ
Рекурзивна функција за факториел
int factorial(int n) {
    if (n <= 1) return 1;
return n * factorial(n - 1);
 }

21.ОБРАТЕН БРОЈ

int obraten(int n) {
    int reverse=0;
    int temp=n;
    while (temp>0) {
        int cifra=temp%10;
        reverse=reverse*10+cifra;
        temp/=10;
    }
    return reverse;


22.ЗБИР НА ДЕЛИТЕЛИ,НЕ СМЕЕШ ОД НУЛА ДА ПОЧНЕШ


int zbirDeliteli(int n) {
    int sum=0;
    for (int i=1;i<=n/2;i++) {//да не се зема предвид самиот број,оди до n/2
        //збир на делители не смееш од 0 да почнеш
        if (n%i==0) {
            sum+=i;
        }
    }
    return sum;
}


23.*Од стандарден влез се читаат знаци се додека не се прочита извичник. Во вака внесениот текст се скриени цели броеви
(помали од 100). Да се напише програма што ќе ги прочита сите знаци и на излез ќе го испечати збирот на сите броеви
скриени во текстот.
Напомена: cin во C++ ги игнорира празните места (space). За да не ги игнорира потребно е да се додаде noskipws
пред читањето на знакот (пр. cin >> noskipws >> znak;)
 */
#include <iostream>
#include <cctype>
using namespace std;

int main() {
    char znak;
    int sum = 0;
    int num = 0;

    while (cin >> noskipws >> znak) {

        if (znak == '!') break;

        if (isdigit(znak)) {
            num = num * 10 + (znak - '0');//бројот што го градиме
        } else {
            sum += num;
            num = 0;
        }
    }
    /*Ако текстот завршува со број, на пример:
  abc12!
  Циклусот ќе чита '1' и '2', num = 12.
  Но кога ќе се прочита '!', влегуваш во if (znak == '!') break; и никогаш не го додаваш последниот број (num) во sum.
  💡 Значи, последниот број се губи ако текстот завршува директно со !.,бидејќи во if го градиш,а го додаваш
  //во else ,т.е кога наидуваш на нешто што не е број,од таа причина бидејќи  if (znak == '!') break;
  одма го прекинува while циклусот и не се извршува ништо подолу затоа надвор од while правиме sum+=num
   */
    sum += num;

    cout << sum << endl;
}



24./*
ТОТАЛНО РАЗЛИЧЕН БРОЈ ПОМАЛ ОД N
Еден број е тотално различен од друг ако и само ако во него не се појавува ниту една од цифрите на другиот број.

#include<iostream>
using namespace std;
int totalnoRazlicen(int n,int x) {
    //totalno razlicen od x

    while (n>0) {
        int temp2=x;
        int cifraN=temp1%10;
        while (temp2>0) {
            int cifraX=temp2%10;

            if (cifraN==cifraX) {
                return 0;

            }
            temp2=temp2/10;
        }
        n=n/10;
    }
    return 1;
}
int main() {
    int n,x;
    cin>>n>>x;
    for (int i=n-1;i>=0;i--) {
        if (totalnoRazlicen(i,x)) {
            cout << i << endl;
            break;
        }
    }
}


25.СТАТИСТИКА НА БРОЕВИ
*Од тастатура се читаат непознат број на позитивни цели броеви (со максимум 5 цифри) се додека не се внесе нешто различно
*од број. За секој број треба да се најде позицијата (од десно на лево) на првото појавување на најголемата цифра во
*составот на бројот (цифрата на единици се наоѓа на позиција 0). Потоа, да се испечати статистика за
*позициите на најдените цифри со максимална вредност во следниот формат:
[позиција]: [вкупно броеви чија максимална цифра се наоѓа на таа позиција]
0: 2

1: 3

2: 1

3: 1

4: 1

за броевите 97654 48654 12345 12343 1263 12443 12643 12777
 */
#include <iostream>
using namespace std;

int main() {
    int stats[5] = {0}; // статистика за позициите 0 до 4
    int number;

    while (cin >> number) {
        if (number <= 0 || number > 99999) continue; // игнорира невалидни броеви

        int temp = number;
        int maxDigit = -1;
        int position = 0;
        int maxPos = -1;

        while (temp > 0) {
            int digit = temp % 10;
            if (digit > maxDigit) {
                maxDigit = digit;
                maxPos = position;
            }
            temp /= 10;
            position++;
        }


            stats[maxPos]++;
        }


    // Печати статистика
    for (int i = 0; i < 5; i++) {
        cout << i << ": " << stats[i] << endl;
    }

    return 0;
}


26.Најмалиот елемент во низата кој се појавува парен број пати во низата.


int minEl = -999999;
    bool found = false;

    for (int i = 0; i < n; i++) {
        int counter = 0;
        for (int j = 0; j < n; j++) {
            if (a[i] == a[j]) {
                counter++;
            }
        }

        if (counter % 2 == 0 && a[i] < minEl) {
            minEl = a[i];
            found = true;
        }
    }

27.АКО НЕШТО Е НАЈДЕНО И НЕ САКАМЕ ДА ПРОДОЛЖИМЕ ПОНАТАКА КОРИСТИМЕ BREAK


