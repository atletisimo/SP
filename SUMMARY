1.Претходно внесен број
-ни треба flag да знаеме каде се наоѓаме
int prethoden = -1;
 bool prv = true; -означува дека се наоѓаме во прв број
    while (cin >> br) {
        if (prv == true) {
            prv = false;

            cout << br << ":" << zbir_cifri(br) << endl;
        } else {
cout<<br<<":"<<max_cifra(prethoden)+zbir_cifri(br)<<endl;
        }
        prethoden=br;//prethoden НЕ СМЕЕ НАДВОР ОД WHILE, бидејќи така ќе се ажурира само еднаш, откако ќе заврши внесувањето на сите броеви.,сега претходен е внесениот број бидејќи
//влегува во првиот ,ако влезе во if-от во таа итерација else делот не се извршува
   //  МОРА ВО РАМКИ НА WHILE
    }



2.
 int statistika[5]={0};
statistika[maxPos]++;//брои колку пати се појавува секоја позиција.На таа позиција која е максимална брои колку пати пример statistika[1] на втора позиција ++ значи имаме 0+1 =1 +1 итн 
//0 бидејќи така е иницијализирана низата


3.Земање наизменично последна,претпоследна цифра
 int prev=num%10;//последната ја зачувуваме
num/=10;//ја отстрануваме
while (num>0) {
int curr=num%10;//претходната е оваа бидејќи уште пред да влеземе во while-от сме ја отстраниле последната 
 prev=curr;//сега curre е prev 
     num/=10;//ја отстрануваме цифрата  и сега повторно почетокот 
ПРИМЕР:num = 394
num = 394
%10
Последна цифра: prev = 4

num станува 39

Итерација 1:

curr = 9 (следна цифра од десно)
prev = 9 поради  prev=curr;

num = 3// num = 39 / 10 = 3




4.НИЗА ПАЛИНДРОМ
bool isPalindrome(char *str) {
    for (int i=0;i<strlen(str)/2;i++) {
        if (str[i]!=str[strlen(str)-1-i]) {//овде е со негација бидејќи за да биде палиндром не смее ниту една да е различна ,ако ставевме обратна логика т.е ако се исти да врати true тоа ќе врати true
//одма без да ја провери целата низа,затоа return true е надвор од for loop-от кога ќе се заврши со проверката ако не е најдена различна тогаш е палиндром
            return false;
        }
    }
    return true;
}





5.ПРЕТВАРАЊЕ ВО МАЛИ БУКВИ 
     // Претвори во мали букви
//ПРЕТХОДНО СИ ИМА ПОСЕБЕН FOR ЗА ЧИТАЊЕ КОЈШТО Е НАДВОРЕШЕН НА РЕЧЕНИЦИ,НО ОВА НИ Е ЗА ДА ЈА ПРЕТВОРИМЕ СЕКОЈА ВО МАЛА БУКВА ,СЕКОЈ 1 КАРАКТЕР ВО РАМКИТЕ НА ТАА РЕДИЦА
        int len = strlen(niz);
        for (int k = 0; k < len; k++) {
            niz[k] = tolower(niz[k]);
        }


6.ВО МАТРИЦА ПРОВЕРКА ПО РЕДИЦИ АКО САКАМЕ 

прво го селектираме for циклусот за редици пример 

 // Проверка по редици
    for (int i = 0; i < m; i++) {
        int rediciCounter = 0;
        bool found = false;
        for (int j = 0; j < n; j++) {
            if (matrica[i][j]==1) rediciCounter++;
            else rediciCounter = 0;

            if (rediciCounter >= 3) found = true;
        }
        if (found) vkupnoRedici++;
    }


ВО МАТРИЦА ПРОВЕРКА ПО КОЛОНИ АКО САКАМЕ 

прво го селектираме for циклусот за колони пример 

// Проверка по колони
    for (int j = 0; j < n; j++) {
        int koloniCounter = 0;
        bool found = false;
        for (int i = 0; i < m; i++) {
            if (matrica[i][j]==1) koloniCounter++;
            else koloniCounter = 0;

            if (koloniCounter >= 3) found = true;
        }
        if (found) vkupnoKoloni++;
    }


7.ПАРНОСТ НА ЕЛЕМЕНТ ДАЛИ Е ИСТ СО ПАРНОСТ НА ЗБИР НА ИДЕКСИТЕ
  if (matrica[i][j]%2==(i+j)%2) 



8.Последнователни појавувања пример на соседни
 *самогласки во речениците.

for (int i=0;i<strlen(str)-1;i++) {//-1 мора да има бидејќи оди до следниот на низата и затоа последната проверка може да се прави кога ќе биде претпоследниот елемент од низата значи за последователни 2
 if ( isVowel(str[i])&& isVowel(str[i+1])) {//isVowel е bool ф-ја која е кориснички дефинирана претходно и овде само ја повикуваме со нејзиниот аргумент
counter++;
}}



9.ПРИМЕР : Да се најде најдолгиот ред во кој има барем 2 цифри
-Мора прво да се исполни условот за барем 2 цифри за да потоа се пребарува најдолгиот ред
-Ако бараме најдолг ред,значи тоа е во рамки на while за секој ред т.е се додека влегува во while,затоа 
  while (true) {
        int counter=0;.....

if (counter>=2) {
        if (strlen(str)>maxRed) {
            maxRed=strlen(str);
            strcpy(najdolgStr,str);
       }
    }



10.PATTERN

1234...N...4321
………..
123454321
1234321
12321
121
1

int main() {
    int n;
    cin>>n;
    for (int i=0;i<n;i++) {//во рамки на редот ,пример првиот
for(int j=1;j<=n-i;j++) { //зависи од редот ова како се намалува n-i => 12345
    cout<<j;
}
        for (int j=n-i-1;j>0;j--) {//ова продолжува во рамки на истиот ред но одпозади за n-1 за да не ни се дуплира n
            cout<<j;
        }

        cout<<endl;
    }
}



PATTERN

1
121
11311
1114111
……
11..1N11...11


 cin>>n;
    for (int i=1;i<=n;i++) {//за секој од редовите 
        for (int j=0;j<i-1;j++) {
cout<<"1";

}
cout<<i;

 for(int j=0;j<i-1;j++){
     cout<<"1";
 }
        cout<<endl;
    }





11.МАТРИЦА СО БУКВИ

редовите со парен индекс (0, 2, 4, ...) се пополнуваат од лево кон десно
редовите со непарен индекс (1, 3, 5, ...) се пополнуваат од десно кон лево
Буквите се користат циклично и по редослед, т.е. после буквата I, се продолжува пак од А.

 int n;
    char bukva='A';
    cin>>n;
    char matrica[100][100];
    for (int i=0;i<n;i++) {
        if (i%2==0){
        for (int j=0;j<n;j++) {
           if (bukva=='I') {
               bukva='A';
           }
                matrica[i][j]=bukva++;
            }
        }
        else {
            for (int j=n-1;j>=0;j--) {
                if (bukva=='I') {
                    bukva='A';
                }
                matrica[i][j]=bukva++;

            }

        }
    }

12.Секоја буква се заменува со буквата што е 3 места понапред во азбуката .За буквите на крајот од азбуката, броењето продолжува циклично од почетокот на азбуката.

char shiftChar(char c) {
    c=tolower(c);
    if (isalpha(c)) {
        c=((c-'a'+3)%26)+'a';
    }
    return c;
}


c - 'a' → ја наоѓа позицијата на буквата во азбуката (пример 'a' = 0, 'b' = 1, … 'z' = 25).

+ 3 → поместува 3 места напред.

% 26 → за да остане во граници на азбуката (ако стигнеме после 'z', да се врати на почеток).

+ 'a' → ја враќа назад во буква.



13.КОЛКУ ПАТИ СЕ ПОЈАВУВА НАЈМАЛЦЕ ЗНАЧАЈНАТА ЦИФРА ВО 1 БРОЈ -ПОСЛЕДНА ЦИФРА Е НАЈМАЛЦЕ ЗНАЧАЈНА %10

int najmalceZnacajna(int n) {
    int temp=n;
    int last=temp%10;
    int counter=0;
while (n>0) {
    if (last==n%10)
    counter++;
    n=n/10;
}
return counter;


}



14./*Напиши програма која ќе чита непознат број од три цели броеви, и за секоја тројка (a, b, c) ќе го испечати бројот
 *(a или b) што ја содржи цифрата c повеќе пати на парни позиции (позициите се бројат од десно кон лево, а првата позиција е 1).
 */
#include<iostream>
using namespace std;
int cifraCTimes(int n,int c) {
    int counter=0;
    int pos=1;
    while (n>0) {
        int cifra=n%10;
        if (cifra==c&&pos%2==0) {
            counter++;

        }
        pos++;
        n=n/10;
    }
    return counter;
}
int main() {
    int a,b,c;
    while (cin>>a>>b>>c) {
int countA=cifraCTimes(a,c);
       int countB= cifraCTimes(b,c);
        if (countA>=countB) {
            cout<<a<<endl;

        }
        else {
            cout<<b<<endl;
        }
    }
}


15./*
 *Прочитај ги димензиите на матрицата ,па самата матрица
 *Прочитајте ги координатите на еден елемент од матрицата.
 *Ако елементот на позицијата за читање е 0, тогаш треба да стане 1 и:
сите нули над тој елемент до првиот елемент со вредност 1 или до почетокот на колоната,
сите нули под тој елемент до првиот елемент со вредност 1 или до крајот на колоната,
сите нули лево од тој елемент до првиот елемент со вредност 1 или до почетокот на редот и
сите нули десно од тој елемент до првиот елемент со вредност 1 или до крајот на редот.
Ако елементот на дадената позиција е 1, тогаш матрицата останува непроменета.
Испечатете ја променетата матрица.
 */
#include <iostream>
using namespace std;

int main() {
 int m, n;
 cin >> m >> n;
 int A[100][100];

 // Вчитување на матрицата
 for (int i = 0; i < m; i++)
  for (int j = 0; j < n; j++)
   cin >> A[i][j];

 int x, y;
 cin >> x >> y; // координати на елементот

 // Проверка дали е 0
 if (A[x][y] == 0) {
  A[x][y] = 1;

  // Горе
  for (int i = x-1; i >= 0; i--) {
   if (A[i][y] == 1) break;
   A[i][y] = 1;
  }

  // Долу
  for (int i = x+1; i < m; i++) {
   if (A[i][y] == 1) break;
   A[i][y] = 1;
  }

  // Лево
  for (int j = y-1; j >= 0; j--) {
   if (A[x][j] == 1) break;
   A[x][j] = 1;
  }

  // Десно
  for (int j = y+1; j < n; j++) {
   if (A[x][j] == 1) break;
   A[x][j] = 1;
  }
 }

 // Печатење на резултатот
 for (int i = 0; i < m; i++) {
  for (int j = 0; j < n; j++) {
   cout << A[i][j] << " ";
  }
  cout << endl;
 }

 return 0;
}


16./*
 *Напишете програма каде што матрицата А прочитана од SI (максималната вредност на димензиите на матрицата е 100)
 се трансформира во нова матрица B. Секој елемент од новата матрица B е збир од позитивни соседи на соодветниот елемент
 од матрицата A. Испечатете ја новата матрица B на стандардниот излез.
 */
#include<iostream>
using namespace std;
int main() {
    int n,m;
    int matrica[100][100];
    int b[100][100];
    cin>>n>>m;
    for (int i=0;i<n;i++) {
        for (int j=0;j<m;j++) {
            cin>>matrica[i][j];
        }
    }
for (int i=0;i<n;i++) {
    for (int j=0;j<m;j++) {
        int suma=0;
        //gore
        if (i-1>=0 && matrica[i-1][j]>0) {
            suma+=matrica[i-1][j];
        }
        //dole
        if (i+1<n &&matrica[i+1][j]>0) {
            suma+=matrica[i+1][j];
        }
        //levo
        if (j-1>=0 && matrica[i][j-1]>0) {
            suma+=matrica[i][j-1];
        }
        //desno
        if (j+1<m &&matrica[i][j+1]>0) {
            suma+=matrica[i][j+1];
        }
        b[i][j]=suma;
    }
}
    for (int i=0;i<n;i++) {
        for (int j=0;j<m;j++) {
            cout<<b[i][j];
        }
        cout<<endl;
    }



}


17.
/*
 *Напишете програма која ќе чита низа (не подолга од 100 знаци) што содржи букви и цифри.
 *Програмата треба да ги испечати на стандардниот излез буквите што се наоѓаат помеѓу првата и втората цифра,
 *од лево кон десно, вклучувајќи ги и самите цифри што ја граничат. Ако низата има само една цифра, програмата треба да
ги испечати сите букви до крајот на низата. Ако низата нема цифри, програмата треба да ја испечати пораката „Нема цифри“
 */
#include<iostream>
#include<cstring>
using namespace std;
int main() {
 char str[100];
 int firstDigit=-1;
 int secondDigit=-1;
 cin.getline(str,100);
 //bukvi megju prva i vtora cifra
 for (int i=0;i<strlen(str);i++) {
  if (isdigit(str[i])) {
   if (firstDigit==-1){
    firstDigit=i;
   }
   else{
    secondDigit=i;
    break;//najdena e vtorata
   }
  }
 }

  if (secondDigit==-1) {//ako ima samo 1 cifra
   for (int i=firstDigit;i<strlen(str);i++) {
    cout<<str[i];
   }
  }
  else if (firstDigit==-1&&secondDigit==-1) {
   cout<<"Nema cifri";
  }
  else {
   for (int i=firstDigit;i<=secondDigit;i++) {
    cout<<str[i];
   }

  }
 }




18./*
*Напишете програма што ќе ја трансформира низата на следниов начин: почнувајќи од почетокот на низата,
за секој елемент што е еднаков на следниот елемент во низата, удвојте ја вредноста на првиот и пребришете ја
втората со 0. После тоа, преуредете ја низата така што сите нули ќе бидат поместени на крајот од низата,
задржувајќи го редоследот на другите елементи. Испечатете ги сите елементи од низата на SO во еден ред,
одделени со празно место.
 */
#include<iostream>
using namespace std;
void transform(int a[],int n) {
    for (int i=0;i<n-1;i++) {
        if (a[i]==a[i+1]) {
            a[i]=a[i]*2;
            a[i+1]=0;
        }
    }
}
void pomestiNuliNaKraj(int a[],int n) {
    int pos=0;
    for (int i=0;i<n;i++) {
        if (a[i]!=0) {
            a[pos++]=a[i];
        }

    }
    while (pos<n) {
        a[pos++]=0;
    }

}
int main() {
    int n;
    int niza[100];
    cin>>n;
    for (int i=0;i<n;i++) {
        cin>>niza[i];
    }
    transform(niza,n);
    pomestiNuliNaKraj(niza,n);
    for (int i=0;i<n;i++) {
        cout<<niza[i]<<" "<<endl;
    }

}



19./*
 *Трансформирајте ја матрицата на начин што сите елементи НАД главната дијагонала ќе бидат поставени на
 *вредноста на максималниот елемент што се наоѓа над главната дијагонала, додека сите елементи ПОД главната
 *дијагонала ќе бидат поставени на вредноста на минималниот елемент што се наоѓа под главната дијагонала.
 *Испечатете ја трансформираната матрица.
 */
#include<iostream>
using namespace std;
int main() {
    int n;
    int matrica[100][100];
    cin>>n;
    for (int i=0;i<n;i++) {
        for (int j=0;j<n;j++) {
            cin>>matrica[i][j];
        }
    }
    //nad glavna dijagonala
    int sum=0;
    int max=matrica[0][1];
    int min=matrica[1][0];
    for (int i=0;i<n;i++) {
        for (int j=0;j<n;j++) {
            if (j>i) {
                if (matrica[i][j]>max) {

                    max=matrica[i][j];
                }
            }
        }
    }
//pod glavna
    for (int i=0;i<n;i++) {
        for (int j=0;j<n;j++) {
            if (j<i) {
                if (matrica[i][j]<min) {

                    min=matrica[i][j];
                }
            }
        }
    }
    for (int i=0;i<n;i++) {
        for (int j=0;j<n;j++) {
            if (j>i) {
                matrica[i][j]=max;
            }
        }
    }
    for (int i=0;i<n;i++) {
        for (int j=0;j<n;j++) {
            if (j<i) {
                matrica[i][j]=min;
            }
        }
    }
    for (int i=0;i<n;i++) {

        for (int j=0;j<n;j++) {
            cout<<matrica[i][j]<<" ";
        }
        cout<<endl;
    }

}



20.ФАКТОРИЕЛ
Рекурзивна функција за факториел
int factorial(int n) {
    if (n <= 1) return 1;
return n * factorial(n - 1);
 }



