1.Претходно внесен број
-ни треба flag да знаеме каде се наоѓаме
int prethoden = -1;
 bool prv = true; -означува дека се наоѓаме во прв број
    while (cin >> br) {
        if (prv == true) {
            prv = false;

            cout << br << ":" << zbir_cifri(br) << endl;
        } else {
cout<<br<<":"<<max_cifra(prethoden)+zbir_cifri(br)<<endl;
        }
        prethoden=br;//prethoden НЕ СМЕЕ НАДВОР ОД WHILE, бидејќи така ќе се ажурира само еднаш, откако ќе заврши внесувањето на сите броеви.,сега претходен е внесениот број бидејќи
//влегува во првиот ,ако влезе во if-от во таа итерација else делот не се извршува
   //  МОРА ВО РАМКИ НА WHILE
    }



2.
 int statistika[5]={0};
statistika[maxPos]++;//брои колку пати се појавува секоја позиција.На таа позиција која е максимална брои колку пати пример statistika[1] на втора позиција ++ значи имаме 0+1 =1 +1 итн 
//0 бидејќи така е иницијализирана низата


3.Земање наизменично последна,претпоследна цифра
 int prev=num%10;//последната ја зачувуваме
num/=10;//ја отстрануваме
while (num>0) {
int curr=num%10;//претходната е оваа бидејќи уште пред да влеземе во while-от сме ја отстраниле последната 
 prev=curr;//сега curre е prev 
     num/=10;//ја отстрануваме цифрата  и сега повторно почетокот 
ПРИМЕР:num = 394
num = 394
%10
Последна цифра: prev = 4

num станува 39

Итерација 1:

curr = 9 (следна цифра од десно)
prev = 9 поради  prev=curr;

num = 3// num = 39 / 10 = 3




4.НИЗА ПАЛИНДРОМ
bool isPalindrome(char *str) {
    for (int i=0;i<strlen(str)/2;i++) {
        if (str[i]!=str[strlen(str)-1-i]) {//овде е со негација бидејќи за да биде палиндром не смее ниту една да е различна ,ако ставевме обратна логика т.е ако се исти да врати true тоа ќе врати true
//одма без да ја провери целата низа,затоа return true е надвор од for loop-от кога ќе се заврши со проверката ако не е најдена различна тогаш е палиндром
            return false;
        }
    }
    return true;
}





5.
