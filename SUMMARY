1.Претходно внесен број
-ни треба flag да знаеме каде се наоѓаме
int prethoden = -1;
 bool prv = true; -означува дека се наоѓаме во прв број
    while (cin >> br) {
        if (prv == true) {
            prv = false;

            cout << br << ":" << zbir_cifri(br) << endl;
        } else {
cout<<br<<":"<<max_cifra(prethoden)+zbir_cifri(br)<<endl;
        }
        prethoden=br;//prethoden НЕ СМЕЕ НАДВОР ОД WHILE, бидејќи така ќе се ажурира само еднаш, откако ќе заврши внесувањето на сите броеви.,сега претходен е внесениот број бидејќи
//влегува во првиот ,ако влезе во if-от во таа итерација else делот не се извршува
   //  МОРА ВО РАМКИ НА WHILE
    }



2.
 int statistika[5]={0};
statistika[maxPos]++;//брои колку пати се појавува секоја позиција.На таа позиција која е максимална брои колку пати пример statistika[1] на втора позиција ++ значи имаме 0+1 =1 +1 итн 
//0 бидејќи така е иницијализирана низата


3.Земање наизменично последна,претпоследна цифра
 int prev=num%10;//последната ја зачувуваме
num/=10;//ја отстрануваме
while (num>0) {
int curr=num%10;//претходната е оваа бидејќи уште пред да влеземе во while-от сме ја отстраниле последната 
 prev=curr;//сега curre е prev 
     num/=10;//ја отстрануваме цифрата  и сега повторно почетокот 
ПРИМЕР:num = 394
num = 394
%10
Последна цифра: prev = 4

num станува 39

Итерација 1:

curr = 9 (следна цифра од десно)
prev = 9 поради  prev=curr;

num = 3// num = 39 / 10 = 3




4.НИЗА ПАЛИНДРОМ
bool isPalindrome(char *str) {
    for (int i=0;i<strlen(str)/2;i++) {
        if (str[i]!=str[strlen(str)-1-i]) {//овде е со негација бидејќи за да биде палиндром не смее ниту една да е различна ,ако ставевме обратна логика т.е ако се исти да врати true тоа ќе врати true
//одма без да ја провери целата низа,затоа return true е надвор од for loop-от кога ќе се заврши со проверката ако не е најдена различна тогаш е палиндром
            return false;
        }
    }
    return true;
}





5.ПРЕТВАРАЊЕ ВО МАЛИ БУКВИ 
     // Претвори во мали букви
//ПРЕТХОДНО СИ ИМА ПОСЕБЕН FOR ЗА ЧИТАЊЕ КОЈШТО Е НАДВОРЕШЕН НА РЕЧЕНИЦИ,НО ОВА НИ Е ЗА ДА ЈА ПРЕТВОРИМЕ СЕКОЈА ВО МАЛА БУКВА ,СЕКОЈ 1 КАРАКТЕР ВО РАМКИТЕ НА ТАА РЕДИЦА
        int len = strlen(niz);
        for (int k = 0; k < len; k++) {
            niz[k] = tolower(niz[k]);
        }


6.ВО МАТРИЦА ПРОВЕРКА ПО РЕДИЦИ АКО САКАМЕ 

прво го селектираме for циклусот за редици пример 

 // Проверка по редици
    for (int i = 0; i < m; i++) {
        int rediciCounter = 0;
        bool found = false;
        for (int j = 0; j < n; j++) {
            if (matrica[i][j]==1) rediciCounter++;
            else rediciCounter = 0;

            if (rediciCounter >= 3) found = true;
        }
        if (found) vkupnoRedici++;
    }


ВО МАТРИЦА ПРОВЕРКА ПО КОЛОНИ АКО САКАМЕ 

прво го селектираме for циклусот за колони пример 

// Проверка по колони
    for (int j = 0; j < n; j++) {
        int koloniCounter = 0;
        bool found = false;
        for (int i = 0; i < m; i++) {
            if (matrica[i][j]==1) koloniCounter++;
            else koloniCounter = 0;

            if (koloniCounter >= 3) found = true;
        }
        if (found) vkupnoKoloni++;
    }


7.

