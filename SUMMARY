1.Претходно внесен број
-ни треба flag да знаеме каде се наоѓаме
int prethoden = -1;
 bool prv = true; -означува дека се наоѓаме во прв број
    while (cin >> br) {
        if (prv == true) {
            prv = false;

            cout << br << ":" << zbir_cifri(br) << endl;
        } else {
cout<<br<<":"<<max_cifra(prethoden)+zbir_cifri(br)<<endl;
        }
        prethoden=br;//prethoden НЕ СМЕЕ НАДВОР ОД WHILE, бидејќи така ќе се ажурира само еднаш, откако ќе заврши внесувањето на сите броеви.,сега претходен е внесениот број бидејќи
//влегува во првиот ,ако влезе во if-от во таа итерација else делот не се извршува
   //  МОРА ВО РАМКИ НА WHILE
    }



2.
 int statistika[5]={0};
statistika[maxPos]++;//брои колку пати се појавува секоја позиција.На таа позиција која е максимална брои колку пати пример statistika[1] на втора позиција ++ значи имаме 0+1 =1 +1 итн 
//0 бидејќи така е иницијализирана низата


3.Земање наизменично последна,претпоследна цифра
 int prev=num%10;//последната ја зачувуваме
num/=10;//ја отстрануваме
while (num>0) {
int curr=num%10;//претходната е оваа бидејќи уште пред да влеземе во while-от сме ја отстраниле последната 
 prev=curr;//сега curre е prev 
     num/=10;//ја отстрануваме цифрата  и сега повторно почетокот 
ПРИМЕР:num = 394
num = 394
%10
Последна цифра: prev = 4

num станува 39

Итерација 1:

curr = 9 (следна цифра од десно)
prev = 9 поради  prev=curr;

num = 3// num = 39 / 10 = 3




4.НИЗА ПАЛИНДРОМ
bool isPalindrome(char *str) {
    for (int i=0;i<strlen(str)/2;i++) {
        if (str[i]!=str[strlen(str)-1-i]) {//овде е со негација бидејќи за да биде палиндром не смее ниту една да е различна ,ако ставевме обратна логика т.е ако се исти да врати true тоа ќе врати true
//одма без да ја провери целата низа,затоа return true е надвор од for loop-от кога ќе се заврши со проверката ако не е најдена различна тогаш е палиндром
            return false;
        }
    }
    return true;
}





5.ПРЕТВАРАЊЕ ВО МАЛИ БУКВИ 
     // Претвори во мали букви
//ПРЕТХОДНО СИ ИМА ПОСЕБЕН FOR ЗА ЧИТАЊЕ КОЈШТО Е НАДВОРЕШЕН НА РЕЧЕНИЦИ,НО ОВА НИ Е ЗА ДА ЈА ПРЕТВОРИМЕ СЕКОЈА ВО МАЛА БУКВА ,СЕКОЈ 1 КАРАКТЕР ВО РАМКИТЕ НА ТАА РЕДИЦА
        int len = strlen(niz);
        for (int k = 0; k < len; k++) {
            niz[k] = tolower(niz[k]);
        }


6.ВО МАТРИЦА ПРОВЕРКА ПО РЕДИЦИ АКО САКАМЕ 

прво го селектираме for циклусот за редици пример 

 // Проверка по редици
    for (int i = 0; i < m; i++) {
        int rediciCounter = 0;
        bool found = false;
        for (int j = 0; j < n; j++) {
            if (matrica[i][j]==1) rediciCounter++;
            else rediciCounter = 0;

            if (rediciCounter >= 3) found = true;
        }
        if (found) vkupnoRedici++;
    }


ВО МАТРИЦА ПРОВЕРКА ПО КОЛОНИ АКО САКАМЕ 

прво го селектираме for циклусот за колони пример 

// Проверка по колони
    for (int j = 0; j < n; j++) {
        int koloniCounter = 0;
        bool found = false;
        for (int i = 0; i < m; i++) {
            if (matrica[i][j]==1) koloniCounter++;
            else koloniCounter = 0;

            if (koloniCounter >= 3) found = true;
        }
        if (found) vkupnoKoloni++;
    }


7.ПАРНОСТ НА ЕЛЕМЕНТ ДАЛИ Е ИСТ СО ПАРНОСТ НА ЗБИР НА ИДЕКСИТЕ
  if (matrica[i][j]%2==(i+j)%2) 



8.Последнователни појавувања пример на соседни
 *самогласки во речениците.

for (int i=0;i<strlen(str)-1;i++) {//-1 мора да има бидејќи оди до следниот на низата и затоа последната проверка може да се прави кога ќе биде претпоследниот елемент од низата значи за последователни 2
 if ( isVowel(str[i])&& isVowel(str[i+1])) {//isVowel е bool ф-ја која е кориснички дефинирана претходно и овде само ја повикуваме со нејзиниот аргумент
counter++;
}}



9.ПРИМЕР : Да се најде најдолгиот ред во кој има барем 2 цифри
-Мора прво да се исполни условот за барем 2 цифри за да потоа се пребарува најдолгиот ред
-Ако бараме најдолг ред,значи тоа е во рамки на while за секој ред т.е се додека влегува во while,затоа 
  while (true) {
        int counter=0;.....

if (counter>=2) {
        if (strlen(str)>maxRed) {
            maxRed=strlen(str);
            strcpy(najdolgStr,str);
       }
    }



10.PATTERN

1234...N...4321
………..
123454321
1234321
12321
121
1

int main() {
    int n;
    cin>>n;
    for (int i=0;i<n;i++) {//во рамки на редот ,пример првиот
for(int j=1;j<=n-i;j++) { //зависи од редот ова како се намалува n-i => 12345
    cout<<j;
}
        for (int j=n-i-1;j>0;j--) {//ова продолжува во рамки на истиот ред но одпозади за n-1 за да не ни се дуплира n
            cout<<j;
        }

        cout<<endl;
    }
}



PATTERN

1
121
11311
1114111
……
11..1N11...11


 cin>>n;
    for (int i=1;i<=n;i++) {//за секој од редовите 
        for (int j=0;j<i-1;j++) {
cout<<"1";

}
cout<<i;

 for(int j=0;j<i-1;j++){
     cout<<"1";
 }
        cout<<endl;
    }





11.МАТРИЦА СО БУКВИ

редовите со парен индекс (0, 2, 4, ...) се пополнуваат од лево кон десно
редовите со непарен индекс (1, 3, 5, ...) се пополнуваат од десно кон лево
Буквите се користат циклично и по редослед, т.е. после буквата I, се продолжува пак од А.

 int n;
    char bukva='A';
    cin>>n;
    char matrica[100][100];
    for (int i=0;i<n;i++) {
        if (i%2==0){
        for (int j=0;j<n;j++) {
           if (bukva=='I') {
               bukva='A';
           }
                matrica[i][j]=bukva++;
            }
        }
        else {
            for (int j=n-1;j>=0;j--) {
                if (bukva=='I') {
                    bukva='A';
                }
                matrica[i][j]=bukva++;

            }

        }
    }

12.
