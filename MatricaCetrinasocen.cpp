/*
Четиринасочник претставува матрица во која се испишани зборови хоризонотално и вертикално, одлево-надесно и оддесно-налево. 
Притоа секој елемент од матрицата претставува буква од англиската азбука. пример скриени зборови: HAIR, OLE (прецртани), FISH, TOE (подвлечени) 
  T H A I R E E S N K N E M I M J O L M F S P S T I F G E L O X U T Y O E 
Од стандарден влез се чита квадратна матрица од ред n (3 <= n <= 50), составена од знаци. Прво се чита бројот n - бројот на редици (колони) на матрицата, 
а потоа и самите елементи на матрицата (види пример). По читањето на матрицата, од стандарден влез се внесува збор составен од максимум 10 букви.
Ваша задача е да определите дали тој збор се наоѓа во четиринасочникот (хоризонтално или вертикално, одлево-надесно или оддесно-налево).
Потребно е да се испечати локацијата (ред, колона) на првата и последната буква од зборот. Доколку зборот повеќепати се наоѓа во четеринасочникот,
треба да се испечати првото појавување, гледано елемент по елемент како што се чита матрицата. Доколку не се пронајде зборот, тогаш се печати Not Found.
*/



#include <iostream>
#include <cstring> // За strlen
using namespace std;

int main() {
    int n;
    cin >> n; // Читање на големината на матрицата (n x n)

    char matrix[50][50]; // Декларација на квадратна матрица со максимална големина 50x50

    // Читање на матрицата од стандарден влез
    for (int i = 0; i < n; i++) {           // За секој ред
        for (int j = 0; j < n; j++) {       // За секоја колона
            cin >> matrix[i][j];            // Читање на еден карактер
        }
    }

    char word[11];          // Масив за внесување на зборот (максимум 10 букви + '\0')
    cin >> word;            // Читање на зборот од стандарден влез
    int len = strlen(word); // Должина на зборот
    bool found = false;     // Променлива која следи дали зборот е пронајден

    // Главна проверка на матрицата
    for (int i = 0; i < n && !found; i++) {     // Секој ред
        for (int j = 0; j < n && !found; j++) { // Секоја колона

            // 1. Хоризонтално од лево кон десно
            if (j + len - 1 < n) { // Проверка дали има доволно место во редот
                bool match = true; // Претпоставуваме дека зборот се совпаѓа
                for (int k = 0; k < len; k++) { // За секоја буква од зборот
                    if (matrix[i][j + k] != word[k]) { // Споредба со матрицата
                        match = false; // Ако не се совпаѓа, прекинува проверката
                        break;
                    }
                }
                if (match) { // Ако се совпаѓа
                    cout << i << ", " << j << " -> " << i << ", " << j + len - 1 << endl;
                    found = true; // Зборот е пронајден
                    break; // Прекинување на колоната
                }
            }

            // 2. Хоризонтално од десно кон лево
            if (j - len + 1 >= 0) { // Проверка дали има место за обратен редослед
                bool match = true;
                for (int k = 0; k < len; k++) {
                    if (matrix[i][j - k] != word[k]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    cout << i << ", " << j << " -> " << i << ", " << j - len + 1 << endl;
                    found = true;
                    break;
                }
            }

            // 3. Вертикално од горе кон доле
            if (i + len - 1 < n) { // Проверка дали има доволно редици подолу
                bool match = true;
                for (int k = 0; k < len; k++) {
                    if (matrix[i + k][j] != word[k]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    cout << i << ", " << j << " -> " << i + len - 1 << ", " << j << endl;
                    found = true;
                    break;
                }
            }

            // 4. Вертикално од долу кон горе
            if (i - len + 1 >= 0) { // Проверка дали има доволно редици нагоре
                bool match = true;
                for (int k = 0; k < len; k++) {
                    if (matrix[i - k][j] != word[k]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    cout << i << ", " << j << " -> " << i - len + 1 << ", " << j << endl;
                    found = true;
                    break;
                }
            }

        }
    }

    if (!found) cout << "Not Found" << endl; // Ако зборот не е пронајден

    return 0;
}

/*
1. Логика

Читаме n и матрицата со n × n букви.

Читаме зборот кој треба да го најдеме (word).

Се проверува:

Хоризонтално: од левo кон десно и од десно кон лево.

Вертикално: од горе кон доле и од долу кон горе.

Ако се најде, печатиме координати на првата и последната буква.

Ако не се најде, печатиме Not Found.
Како работи кодот

a) Читање на матрицата

char matrix[50][50]; → создава матрица од максимално 50x50 знаци.

cin >> matrix[i][j]; → чита по еден карактер од стандарден влез.

Читањето е ред по ред, колона по колона.

b) Читање на зборот

char word[11]; → создава масив за зборот со максимум 10 букви.

strlen(word) → ја дава точната должина на зборот.

found → булова променлива која го следи дали зборот е пронајден, за да можеме да излеземе од циклусите.

c) Проверка на сите насоки
1. Хоризонтално лево → десно

if (j + len - 1 < n) → осигуруваме дека зборот ќе се вклопи во редот без да излезе надвор.

for (int k = 0; k < len; k++) → проверка за секоја буква од зборот.

matrix[i][j + k] != word[k] → споредба на матрицата и зборот.

Ако се совпаѓа, печатиме координати на почетна и крајна буква: (i,j) -> (i,j+len-1).

2. Хоризонтално десно → лево

if (j - len + 1 >= 0) → осигуруваме дека зборот може да се смести назад.

Споредба е иста, само насоката е обратна: matrix[i][j - k].

3. Вертикално горе → доле

if (i + len - 1 < n) → осигуруваме дека зборот ќе се смести вертикално.

Проверка: matrix[i+k][j].

4. Вертикално доле → горе

if (i - len + 1 >= 0) → осигуруваме дека зборот ќе се смести нагоре.

Проверка: matrix[i-k][j].

d) Излез

Ако зборот е пронајден → печатиме координати на првата и последната буква.

Ако не е пронајден → печатиме "Not Found".

e) Клучни точки

Кодот проверува секоја ќелија на матрицата.

Се проверуваат четири насоки (лево-десно, десно-лево, горе-долу, доле-горе).

found служи за да излеземе веднаш по првото појавување на зборот.

Користиме масиви од char наместо string.

*/
